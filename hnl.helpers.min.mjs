export function objForEach(object,callback,callbackDone,thisArg=window){if(typeof object!=="object"||object===null)throw new TypeError("Not an object");let c=0;for(const key in object){if(Object.prototype.hasOwnProperty.call(object,key))callback.call(thisArg,key,object[key],c,object);c++}if(typeof callbackDone==="function")callbackDone.call(thisArg)}export function forEachBatched(obj,callback,doneCallback,batchSize=100){if(obj==null||typeof obj!=="object")throw new TypeError("Invalid input. Expected an object.");
if(typeof callback!=="function"||typeof doneCallback!=="function")throw new TypeError("Invalid callback function(s).");const keys=Object.keys(obj);const len=keys.length;let i=0;const interval=10;const processData=start=>{let end=Math.min(start+batchSize,len);while(start<end){const key=keys[start];callback.call(obj,obj[key],key,obj);start++}if(start<len)setTimeout(()=>processData(start),interval);else doneCallback.call(obj,obj[keys[len-1]],keys[len-1],obj)};processData(i)}export function isVisibleNow(element,
callback,options={}){const {rootMargin="0px",threshold=[0,1]}=options;if(!(element instanceof Element))throw new TypeError("Not a valid node");const observer=new IntersectionObserver(entries=>{entries.forEach(entry=>{const visible=entry.intersectionRatio>0;const fullyVisible=entry.intersectionRatio===1;if(typeof callback==="function")callback(visible,fullyVisible,entry)})},{rootMargin,threshold});observer.observe(element);return()=>{observer.disconnect()}}export function isResizedNow(element,callback){if(typeof ResizeObserver!==
"function"){console.warn("ResizeObserver is not supported in this browser.");return}const resizeObserver=new ResizeObserver(entries=>{for(let entry of entries)callback(entry)});resizeObserver.observe(element);return()=>{resizeObserver.unobserve(element);resizeObserver.disconnect()}}export async function watchVisibility(element,callback=null){const visibilityObserver=isVisibleNow(element,(isVisible,isFullyVisible,visData)=>{element.dataset.visible=isVisible;element.dataset.fullyVisible=isFullyVisible;
const resizeObserver=isResizedNow(element,resData=>{if(typeof callback==="function")callback.call(this,isVisible,isFullyVisible,{visibilityObserver,resizeObserver,visibility_data:visData,resize_data:resData})})})}export function isVisible(element,callback,vp={}){if(!(element instanceof Element))throw new TypeError("Not a valid node");if(typeof element.getBoundingClientRect==="function"){const rect=element.getBoundingClientRect();const scrollTop=window.pageYOffset||document.documentElement.scrollTop;
const scrollLeft=window.pageXOffset||document.documentElement.scrollLeft;const clientTop=document.documentElement.clientTop;const clientLeft=document.documentElement.clientLeft;rect.pageY=rect.top+scrollTop-clientTop;rect.pageX=rect.left+scrollLeft-clientLeft;const viewport={top:typeof vp.top!=="undefined"?vp.top:0,bottom:typeof vp.bottom!=="undefined"?vp.bottom:window.innerHeight||document.documentElement.clientHeight,left:typeof vp.left!=="undefined"?vp.left:0,right:typeof vp.right!=="undefined"?
vp.right:window.innerWidth||document.documentElement.clientWidth};const fullyVisible=(rect.height>0||rect.width>0)&&rect.bottom<viewport.bottom&&rect.right<viewport.right&&rect.top>viewport.top&&rect.left>viewport.left;const visible=(rect.height>0||rect.width>0)&&rect.bottom>=0&&rect.top<=viewport.bottom&&(rect.right>viewport.left&&rect.right<=viewport.right||rect.left<viewport.right&&rect.left>=viewport.left);if(typeof callback==="function")callback.call(this,visible,fullyVisible,rect)}else console.error("Can't check visibility for",
typeof this,this)}export function getScriptPath(){if("noModule"in HTMLScriptElement.prototype&&typeof import.meta!=="undefined"&&typeof import.meta.url==="string")return(new URL(import.meta.url)).pathname;else{let uriRegex=new RegExp(/\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?\u00c2\u00ab\u00c2\u00bb\u00e2\u20ac\u0153\u00e2\u20ac\u009d\u00e2\u20ac\u02dc\u00e2\u20ac\u2122]))/ig);
let traceUrls=(new Error).stack.match(uriRegex);return traceUrls[traceUrls.length-1].substring(0,traceUrls[traceUrls.length-1].lastIndexOf("/"))}}export function writeCSS(src){if(!src)throw new Error(`No CSS file path provided`);const link=document.createElement("link");link.setAttribute("type","text/css");link.setAttribute("rel","stylesheet");link.setAttribute("href",src);document.head.appendChild(link);return true}export function cleanUpString(string){return string.replace(/(<([^>]+)>)/ig,"").replace(/\s{2,}/g,
" ").trim()}export function formatPhone($phone){let ret=[],countryPrefix,phone;const whiteSpace=/\s+/g;const areaPrefix=["06","0909","0906","0900","0842","0800","0676","06","010","046","0111","0475","0113","0478","0114","0481","0115","0485","0117","0486","0118","0487","013","0488","015","0492","0161","0493","0162","0495","0164","0497","0165","0499","0166","050","0167","0511","0168","0512","0172","0513","0174","0514","0180","0515","0181","0516","0182","0517","0183","0518","0184","0519","0186","0521",
"0187","0522","020","0523","0222","0524","0223","0525","0224","0527","0226","0528","0227","0529","0228","053","0229","0541","023","0543","024","0544","0251","0545","0252","0546","0255","0547","026","0548","0294","055","0297","0561","0299","0562","030","0566","0313","0570","0314","0571","0315","0572","0316","0573","0317","0575","0318","0577","0320","0578","0321","058","033","0591","0341","0592","0342","0593","0343","0594","0344","0595","0345","0596","0346","0597","0347","0598","0348","0599","035",
"070","036","071","038","072","040","073","0411","074","0412","075","0413","076","0416","077","0418","078","043","079","045"];const areaPrefixSeparator=" - ";phone=(typeof $phone!=="string"?$phone.join(""):clean_string($phone)).replace(whiteSpace,"");if(phone.slice(0,2)==="00"||phone.slice(0,1)==="+"){countryPrefix=phone.slice(0,1)==="+"?phone.slice(0,3):phone.slice(0,4);phone="0"+phone.substring(countryPrefix.length);ret.push(countryPrefix)}let x=5,kental=phone.slice(0,3);while(x--)if(areaPrefix.includes(phone.slice(0,
x))){kental=phone.slice(0,x);break}phone=phone.substring(kental.length);ret.push(kental.substr(countryPrefix?1:0)+areaPrefixSeparator);let regex=phone.length>7?/(\d{2,3})(\d{2})(\d{2})(\d{2})/i:/(\d{2,3})(\d{2})(\d{2})/i;let matches=phone.match(regex);if(matches){matches.shift();ret.push(matches.join(" "));return ret.join(" ").replace(/\s{2,}/g," ")}else return $phone}export function formatHref(urlString){const https="https:";const parts=urlString.split("//");const uri=parts.length===1?parts[0]:parts[1];
return(https+"//"+uri).replace(/\/{3,}/g,"//")}export function formatString(string,validateAs="auto"){string=cleanUpString(string);const digitString=(string.match(/\d+/g)||[]).join("");const wordString=(string.match(/[A-Za-z]+/g)||[]).join("");if(digitString.length>9&&digitString.length<12&&!wordString.length||validateAs==="phone")return formatPhone(digitString);else if(/^https?:\/\/\S+|www\.\S+/.test(string))return formatHref(string);else return string}export function toMS(s){return parseFloat(s)*
(/\ds$/.test(s)?1E3:1)}export function snapScrollComplete(element,callbackSnap,callbackStop){let timeout=null;element.addEventListener("scroll",e=>{let atSnappingPoint=e.target.dataset.scrollDirection==="horizontal"?e.target.scrollLeft%e.target.offsetWidth===0:e.target.scrollTop%e.target.offsetHeight===0;let timeOut=atSnappingPoint?0:150;clearTimeout(timeout);timeout=null;timeout=setTimeout(function(){if(!timeOut){e.target.dispatchEvent(new Event("scrollSnapped"));if(typeof callbackSnap==="function")callbackSnap.call(this)}else{e.target.dispatchEvent(new Event("scrollStopped"));
if(typeof callbackStop==="function")callbackStop.call(this)}e.target.dispatchEvent(new Event("scrollStoppedSnapped"))},timeOut)})}export class FpsCounter{constructor(callback){this.timeStamps=[performance.now()];this.fpsEvent=new CustomEvent("fpsUpdate",{detail:this,bubbles:true,cancelable:true});this.callback=typeof callback==="function"?callback:null;this.fps=60;this.fpsTimer=this.fpsTimer.bind(this);this.start()}fpsTimer(now){this.timeStamps=this.timeStamps.filter(time=>now-time<=1E3);this.realFPS=
this.timeStamps.length>1?1E3/(now-this.timeStamps[this.timeStamps.length-1]):this.fps;this.timeStamps.push(now);this.fps=Math.round((this.timeStamps.length+this.realFPS)/2);window.dispatchEvent(this.fpsEvent);if(this.callback)this.callback.call(this,this.fps);this.requestId=requestAnimationFrame(this.fpsTimer)}start(){this.requestId=requestAnimationFrame(this.fpsTimer)}}export class EasedMeanCalculator{constructor(){this.history={}}getValue(value,type="default",range=3){if(!this.history[type])this.history[type]=
[];this.history[type].push(value);const historyToUse=this.history[type].slice(-range);return historyToUse.reduce((sum,val)=>sum+val,0)/historyToUse.length}reset(type){this.history[type]=[]}}export function getRandomInt(min,max){min=Math.ceil(min);max=Math.floor(max);return Math.floor(Math.random()*(max-min+1))+min}export function cubicBezier(controlPoints,t){const [x1,y1,x2,y2]=controlPoints;const cx=3*x1;const bx=3*(x2-x1)-cx;const ax=1-cx-bx;const cy=3*y1;const by=3*(y2-y1)-cy;const ay=1-cy-by;
function sampleCurveX(t){return((ax*t+bx)*t+cx)*t}function solveCurveX(x,epsilon){let t2=x,d2,i;for(i=0;i<8;i++){const x2=sampleCurveX(t2)-x;if(Math.abs(x2)<epsilon)return t2;d2=(3*ax*t2+2*bx)*t2+cx;if(Math.abs(d2)<1E-6)break;t2-=x2/d2}const t1=t2-x2/d2;return t1}function sampleCurveY(t){return((ay*t+by)*t+cy)*t}const t1=solveCurveX(t,1E-6);return sampleCurveY(t1)}export function pageScrollPercentage(){const scrollPosition=window.scrollY||window.pageYOffset||document.documentElement.scrollTop;const totalHeight=
document.documentElement.scrollHeight-window.innerHeight;if(totalHeight<=0)return 100;return Math.min(100,Math.max(0,scrollPosition/totalHeight*100))}export function stringToObj(string){let tmp=document.createElement("div");tmp.innerHTML=string;return tmp.childNodes.length===1?tmp.firstChild:tmp.childNodes};
